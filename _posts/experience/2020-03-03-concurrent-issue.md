---
layout: post
title: 线上事故总结 - 对线程不安全的思考
categories: Experiences, Code Reviews, Concurrent
date: 2020-03-02 22:10:00
pid: 20200302-221000
pin: 100
---

## 线上事故总结 - 对线程不安全的思考

{% include toc %}

### 背景

为了提高性能，和减少停机时间，我提出了重构跑了7年的订单处理模块，在代码层面进行SQL拼接，而不是从在Oracle的存储过程里面处理。因为存储过程在DB里面进行SQL拼接和计算，更新的时候会重新编译而使得必须停机，而且使用的是DB的资源，不利于App的横向扩展。

### 案发线程

DB保存到的数据和请求的数据有些字段不一样，因为DB的设计上有预留到一些冗余字段用于校验，所以我们很轻松就可以统计到异常的数据，发现只有少部分的数据有问题，而且有问题的数据时间点都比较集中。
因为功能都是通过了UAT和Pre-Prd的测试才上线的，所以是不会有问题的。这时候我们就想会不会是线程不安全的问题，于是校验对了同一时间的订单，发现他们用了另外一张订单的数据。

### 发现凶手

设计的时候，我要求要用状态机来控制订单的状态，结果他写了一个ability类，Ability有各种boolean成员变量标记订单能干什么，不能干什么。然后让不同订单类型的services继承了这个ability类。
在spring里面，注入的services是一个单例来的，不同http请求都会都访问同一个services实例，父类的ability下的变量成员是会被多个线程修改。

### 修改

在并发编程下有一个概念叫可重入函数/不可重入函数概念

```

可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；
而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，

```
单例下的成员变量算是一个全局变量区，所以不符合可重入函数这个概念。

其实我们可以借鉴Unity3D中的ECS修复这个问题，一张订单就是一个entity，不同类型的订单属于不同类型的component，而状态机就是一个system。System对于不同的component有不同的处理行为。
在ECS中，component是包含一堆数据，不包含函数。而System里面则是只有函数，而不含有数据。也符合上诉所说的可重入函数概念。


### 如何避免

依赖人工的Code Review难免有漏网之鱼。在想不到开发阶段完全避免下，制定一些保险措施能将损失减少。

1. 压测
线程安全问题很难在平时的功能测试中发现，而需要在并发环境下，而压测就是一个很好的环境
但是接口越来越多，压测很难覆盖全面。在自动化测试都没有普及的今天，全自动压测环境对于一个小团队是一个小的成本支出。

2. 金丝雀测试
先发布部分应用，并在DB下记下处理的app编号，用于数据校验是定位出问题的app。
```
注释：矿井中的金丝雀
17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离。
```